<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Boeing 787 Sliding Puzzle</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<h2>Boeing 787 Sliding Puzzle â€“ Rebuild the Fleet </h2>
<p>Click tiles adjacent to empty space to slide them!</p>
<canvas id="puzzle" width="450" height="450"></canvas>

<script>
const img = new Image();
img.src = "https://imgs.search.brave.com/hyrKRM0357hK7zBIP4iJXVIz02r1E0n3VNDUe81KtSw/rs:fit:860:0:0:0/g:ce/aHR0cHM6Ly90NC5m/dGNkbi5uZXQvanBn/LzA0Lzk0LzE2LzIz/LzM2MF9GXzQ5NDE2/MjMzMV9xejBmYXRL/R1RrZDlaeFpGNmVU/ajhhTHExOElWVWRT/Zi5qcGc";
const canvas = document.getElementById('puzzle');
const ctx = canvas.getContext('2d');

const rows = 3, cols = 3, size = 150;
const emptyIndex = 6;
let tiles = [];

img.onload = () => {
  for (let i = 0; i < rows * cols; i++) {
    if (i !== emptyIndex) tiles.push(i);
    else tiles.push(null);
  }
  shuffleBoard();
  draw();
};

function shuffleBoard() {
  let tilePositions = tiles.filter(t => t !== null);
  for (let i = tilePositions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [tilePositions[i], tilePositions[j]] = [tilePositions[j], tilePositions[i]];
  }
  let pos = 0;
  for (let i = 0; i < tiles.length; i++) {
    if (i !== emptyIndex) {
      tiles[i] = tilePositions[pos];
      pos++;
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let i = 0; i < tiles.length; i++) {
    if (tiles[i] === null) {
      let dx = (i % cols) * size;
      let dy = Math.floor(i / cols) * size;
      ctx.fillStyle = '#fffaf0';
      ctx.fillRect(dx, dy, size, size);
      continue;
    }
    let sx = (tiles[i] % cols) * size;
    let sy = Math.floor(tiles[i] / cols) * size;
    let dx = (i % cols) * size;
    let dy = Math.floor(i / cols) * size;
    ctx.drawImage(img, sx, sy, size, size, dx, dy, size, size);
  }
}

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const clickedIndex = Math.floor(y / size) * cols + Math.floor(x / size);
  const emptyPos = tiles.indexOf(null);

  const canMove = (
    (clickedIndex === emptyPos - 1 && clickedIndex % cols !== cols - 1) ||
    (clickedIndex === emptyPos + 1 && clickedIndex % cols !== 0) ||
    (clickedIndex === emptyPos - cols) ||
    (clickedIndex === emptyPos + cols)
  );

  if (canMove) {
    tiles[emptyPos] = tiles[clickedIndex];
    tiles[clickedIndex] = null;
    draw();
    checkCompletion();
  }
});

// Fetch secret from server when puzzle is solved
async function checkCompletion() {
  for (let i = 0; i < tiles.length; i++) {
    if (tiles[i] !== null && tiles[i] !== i) return false;
  }

  try {
    const res = await fetch('/getSecret');
    const data = await res.json();
    if (data.success) {
      alert(`SECRET MESSAGE IS "${data.message}" ðŸš€`);
    } else {
      alert('Something went wrong...');
    }
  } catch (err) {
    alert('Server error, try again.');
  }
  return true;
}
</script>
</body>
</html>
